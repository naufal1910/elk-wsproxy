input {
  file {
    path => "/logs/proxyws.log"
    start_position => "beginning"
    sincedb_path => "/usr/share/logstash/data/sincedb-wsproxy"
    codec => plain { charset => "UTF-8" }
  }
}

filter {
  grok {
    match => {
      "message" => [
        "%{TIMESTAMP_ISO8601:tmp.ts} %{LOGLEVEL:[log][level]} \\[%{DATA:[process][thread][name]}\\] %{DATA:[log][logger]} :: %{GREEDYDATA:msg}"
      ]
    }
    tag_on_failure => []
  }

  date {
    match => ["[tmp][ts]","yyyy-MM-dd HH:mm:ss,SSS"]
    timezone => "Asia/Jakarta"
  }

  grok {
    match => { "msg" => ["%{DATA:[event][action]}\\s+payload %{GREEDYDATA:tmp.after_action}"] }
    tag_on_failure => []
  }

  if [msg] =~ "payload header" {
    grok { match => { "msg" => [".*payload header : %{GREEDYDATA:tmp.header_str}$"] } tag_on_failure => [] }
    kv {
      source => "[tmp][header_str]"
      field_split => "\|"
      value_split => " = "
      target => "[http][request][headers]"
      trim_key => " "
      trim_value => " "
    }
    ruby {
      code => '
        h = event.get("[http][request][headers]")
        if h.is_a?(Hash)
          h.keys.each do |k|
            v = h.delete(k)
            nk = k.to_s.downcase.gsub("-", "_").strip
            h[nk] = v
          end
          event.set("[http][request][headers]", h)
        end
      '
    }
  }

  if [msg] =~ "payload request" {
    grok { match => { "msg" => [".*payload request :%{GREEDYDATA:tmp.request_raw}$"] } tag_on_failure => [] }
    json { source => "[tmp][request_raw]" target => "request" skip_on_invalid_json => true }
  }

  if [msg] =~ "payload response" {
    grok { match => { "msg" => [".*payload response :%{GREEDYDATA:tmp.response_raw}$"] } tag_on_failure => [] }
    json { source => "[tmp][response_raw]" target => "response" skip_on_invalid_json => true }
  }

  ruby {
    init => 'require "digest"'
    code => '
      ok = false
      resp = event.get("response")
      if resp.is_a?(Hash)
        code = resp["responseCode"]
        ok ||= ["000","00","200","201"].include?(code)
        hcr = resp["healthCheckResp"]
        ok ||= (hcr.to_s.downcase == "successfull")
        resp["success"] = ok
        event.set("response", resp)
      end

      req = event.get("request") || {}
      out = {}
      ["cipheredCardInfo","authenticationValue","tokenInfo"].each do |k|
        val = req[k]
        if val.is_a?(String) && !val.empty?
          out[k] = Digest::SHA256.hexdigest(val)
          req.delete(k)
        end
      end
      event.set("request_hash", out) unless out.empty?
      event.set("request", req)
    '
  }

  mutate {
    add_field => { "[service][name]" => "wsproxy" }
    add_field => { "env" => "dev" }
    remove_field => ["tmp","msg"]
  }
}

output {
  elasticsearch {
    hosts => ["http://es-wsproxy:9200"]
    user  => "elastic"
    password => "elastic123"
    index => "wsproxy-%{+YYYY.MM.dd}"
  }
  stdout { codec => rubydebug }
}

# ======================= Tomcat Access Logs -> Elasticsearch =======================
input {
  file {
    path => "/tomcat-logs/localhost_access_log*.txt"
    start_position => "beginning"
    sincedb_path   => "/usr/share/logstash/data/sincedb-tomcat-access"
    codec => plain { charset => "UTF-8" }
    add_field => { "[@metadata][source]" => "tomcat_access" }
  }
}

filter {
  if [@metadata][source] == "tomcat_access" {

    # Your Tomcat pattern: %h %l %u %t "%r" %s %b %D %T
    grok {
      match => {
        "message" => [
          '%{IPORHOST:client.ip} %{USER:ident} %{USER:auth} \[%{HTTPDATE:access.time}\] "%{WORD:[http][request][method]} %{URIPATHPARAM:[http][request][path]}(?:%{URIPARAM:query})? HTTP/%{NUMBER:[http][version]}" %{NUMBER:[http][response][status_code]:int} (?:%{NUMBER:[http][response][bytes]:int}|-) %{NUMBER:[http][response][time_us]:int} %{NUMBER:[http][response][time_s]:float}'
        ]
      }
      tag_on_failure => ["_grok_tomcat_fail"]
    }

    date {
      match    => ["access.time","dd/MMM/yyyy:HH:mm:ss Z"]
      target   => "@timestamp"
      timezone => "Asia/Jakarta"   # your TZ
    }

    mutate {
      add_field => { "[service][name]" => "tomcat" }
      add_field => { "env" => "dev" }
      convert   => { "[http][response][bytes]" => "integer" }
    }

    ruby {
      code => '
        t_us = event.get("[http][response][time_us]")
        event.set("[http][response][time_ms]", t_us.to_f / 1000.0) if t_us
      '
    }

    ruby {
      code => '
        sc = event.get("[http][response][status_code]")
        if sc.is_a?(Integer)
          outcome = sc >= 500 ? "failure" : (sc >= 400 ? "client_error" : "success")
          h = event.get("event") || {}
          h["outcome"] = outcome
          event.set("event", h)
        end
      '
    }

    ruby {
      code => '
        p = event.get("[http][request][path]")
        if p.is_a?(String)
          segs = p.split("/").reject(&:empty?)
          section = segs[0] ? "/" + segs[0] : "/"
          section2 = segs[1] ? (section + "/" + segs[1]) : section
          event.set("[url][path]", p)
          event.set("[url][section]", section2)
        end
      '
    }

    mutate { remove_field => ["ident","auth","access.time"] }
  }
}

output {
  if [@metadata][source] == "tomcat_access" {
    elasticsearch {
      hosts    => ["http://es-wsproxy:9200"]
      user     => "elastic"
      password => "elastic123"
      index    => "tomcat-access-%{+YYYY.MM.dd}"
    }
    stdout { codec => rubydebug }
  }
}
